## 01. 什么是线程和进程

### 区别
进程有独立的内存空间，每个进程间的数据是不共享的。
线程是进程中的一个任务执行单元，堆空间和方法区是共享的 （Metaspace），栈空间和程序计数器是独立的。

### 关系
线程是进程中的执行单元，一个进程中执行任务时，可以产生多个线程。

### 线程的上下文切换
前提：一个CPU核在同一时间只能被一个线程使用，为了最大化CPU的利用率，使用时间片算法将CPU的时间轮流分配
给多个线程。每个线程分配一个时间片，当时间片用完后，线程会挂起，然后CPU再分配给其他线程。

线程的程序计数器记录该线程中正在执行的程序指令的位置（上下文），和即将执行的下一个指令的位置。
当线程任务被挂起时，将该线程的程序计数器的状态（上下文）存储在内存中。
从内存中检索到下一个任务（线程）的上下文并在CPU寄存器中恢复，并跳转到该线程程序计数器指定的位置。

### 并发与并行的的区别
并发指的是多个任务在有交集的时间区间内，开始，执行和终止。没有特定的执行顺序。
并行特指多个任务同一时间开始并执行。

从实现的角度上说：并发允许多个任务之间存在相互依赖以及相互切换。并行要求多个任务之间互不干扰。

## 02. 使用多线程所带来的问题

大多数情况，多线程可以充分利用任务不必要的等待时间，来起到快速执行任务的目的。

问题：
1. 线程过多时，多个线程的上下文切换会产生的额外性能开销。
2. 线程安全问题，线程和线程之间在同时读/写共享内存中的对象时，会对结果产生难以估测的影响。

### 线程安全问题
主要分为两个场景
1. 多个线程同时读/写共享内存中的数据。
由于线程之间存在race condition，所以存在两个线程同时写数据时，旧数据覆盖新数据。
一个线程在读一个正在被写的数据时，没有读到更新后的数据。

2. 线程之间互相依赖产生死锁
当我们想加入锁来保证共享数据的读/写有序性的时候，存在两个线程各自获得了对方想尝试acquire的锁，
从而导致两个线程都无法继续执行下去，造成死锁。

### 原子性，有序性，可见性
**原子性**：程序语言中的一个操作或多个操作，要么同时执行，要么都不执行。
**有序性**：代码会按照程序语言中的执行顺序执行（不受编译器会以优化为目的进行指令重排）。
**可见性**：当多个线程访问一个变量时，该变量的状态更新可以立即被其他线程看到
    - 在多核CPU中，每个核有自己的缓存，并缓存共享内存中的对象。当多核CPU之间并行时，线程读/写的是自己所在核的缓存，
    可能会导致在多核线程所读写的对象值不一致。
    - 通过跳过CPU高级缓存直接读/写共享内存来保证可见性。

## 03. 什么是死锁，如何排查？

当我们想加入锁来保证共享数据的读/写有序性的时候，存在两个线程各自获得了对方想尝试acquire的锁，
从而导致两个线程都无法继续执行下去，造成死锁。

排查：使用jstack来生成当前JVM中所有线程的snapshots。snapshot包括每一条线程中正在执行的方法堆栈的
集合。主要目的是定位线程中出现的长时间停顿的原因，包括死循环，死锁，请求外部资源导致的时间过长等。
